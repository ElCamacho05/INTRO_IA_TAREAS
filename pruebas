import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import numpy as np
import igraph
from igraph import Graph, EdgeSeq
import plotly.graph_objects as go

expandidos = []
mov = 0.5 # tamanio de paso del robot

def get_nodos(raiz):
    nodos = []
    por_visitar = [raiz]
    visitados = []

    while por_visitar != []:
        nodo = por_visitar.pop(0)
        if (nodo in visitados) or (nodo in nodos):
            continue
        nodos.append(nodo)

        por_visitar += nodo.hijos
        visitados.append(nodo)

    return nodos

def get_etiquetas(nodos):
    labels = []
    for nodo in nodos:
        labels.append(
            str(nodo.pos)
        )
    return labels

def crear_grafo(nodos, etiquetas):
    
    g = Graph(directed = True)

    for nodo in nodos:
        g.add_vertex(etiquetas[nodos.index(nodo)])
    padre_hijo = []
    for nodo in nodos:
        
        padre_hijo.append([nodo.papa, nodo])
    for r in padre_hijo:
        if r[0]:  # tiene papa
            g.add_edge(etiquetas[nodos.index(r[0])], etiquetas[nodos.index(r[1])])

    edges = [e.tuple for e in g.es]
    
    return g, edges
    
def dibujar_grafo(grafo, labels):
    # Encontrar raíz: nodo sin padres (grado de entrada 0)
    raices = [v.index for v in grafo.vs if grafo.degree(v, mode="in") == 0]
    if len(raices) != 1:
        return f"SHay {len(raices)}, imposible ejecutar"
    root_idx = raices[0]

    layout = grafo.layout_reingold_tilford(mode="out", root=[root_idx]) # out, que no se graficque hacia los lados, sino hacia abajo

    Xn = [pos[0] for pos in layout]
    Yn = [-pos[1] for pos in layout]  # y negativa: hacia abajo

    Xe, Ye = [], []
    for edge in grafo.get_edgelist():
        Xe += [Xn[edge[0]], Xn[edge[1]], None]
        Ye += [Yn[edge[0]], Yn[edge[1]], None]

    trace_edges = go.Scatter(
        x=Xe, y=Ye,
        mode='lines',
        line=dict(width=1, color='gray'),
        hoverinfo='none'
    )

    trace_nodes = go.Scatter(
        x=Xn, y=Yn,
        mode='markers',
        marker=dict(symbol="circle-dot", size=30, color="lightblue", line=dict(width=2)),
        text=labels,
        textposition="middle center",
        hoverinfo="text"
    )

    fig = go.Figure(data=[trace_edges, trace_nodes],
                    layout=go.Layout(title="Arbol 8 puzzle",
                                     showlegend=True,
                                     margin=dict(b=20, l=5, r=5, t=40),
                                     xaxis=dict(showgrid=False, zeroline=False),
                                     yaxis=dict(showgrid=False, zeroline=False)))
    fig.show()

def dibujar_grafo_anim(grafo, labels):
    raices = [v.index for v in grafo.vs if grafo.degree(v, mode="in") == 0]
    if len(raices) != 1:
        raise ValueError(f"Se esperaba 1 raíz, pero hay {len(raices)}")

    root_idx = raices[0]
    layout = grafo.layout_reingold_tilford(mode="out", root=[root_idx])
    Xn = [pos[0] for pos in layout]
    Yn = [-pos[1] for pos in layout]

    # Preparar nodos y aristas para cada frame
    frames = []
    num_nodos = len(grafo.vs)
    for i in range(1, num_nodos + 1):
        # Aristas visibles hasta este nodo
        Xe, Ye = [], []
        for edge in grafo.get_edgelist():
            if edge[0] < i and edge[1] < i:
                Xe += [Xn[edge[0]], Xn[edge[1]], None]
                Ye += [Yn[edge[0]], Yn[edge[1]], None]

        trace_edges = go.Scatter(
            x=Xe, y=Ye,
            mode='lines',
            line=dict(width=1, color='gray'),
            hoverinfo='none'
        )

        trace_nodes = go.Scatter(
            x=Xn[:i], y=Yn[:i],
            mode='markers',
            marker=dict(symbol="circle-dot", size=30, color="lightblue", line=dict(width=2)),
            text=labels[:i],
            textposition="middle center",
            hoverinfo="text"
        )

        frames.append(go.Frame(data=[trace_edges, trace_nodes], name=str(i)))

    # Frame inicial
    initial_edges = go.Scatter(x=[], y=[], mode='lines')
    initial_nodes = go.Scatter(x=[], y=[], mode='markers')

    fig = go.Figure(
        data=[initial_edges, initial_nodes],
        layout=go.Layout(
            title="Árbol 8 Puzzle (Animado)",
            showlegend=True,
            margin=dict(b=20, l=7, r=5, t=40),
            xaxis=dict(showgrid=False, zeroline=False),
            yaxis=dict(showgrid=False, zeroline=False),
            updatemenus=[dict(
                type="buttons",
                buttons=[dict(label="▶️ Reproducir",
                              method="animate",
                              args=[None, {"frame": {"duration": 500, "redraw": True},
                                           "fromcurrent": True, "transition": {"duration": 0}}])],
                showactive=False,
                x=0.1, y=-0.1
            )]
        ),
        frames=frames
    )

    fig.show()

def dibujar(gp):
    plt.grid(True)
    plt.scatter(gp[0], gp[1], c="c") # dibula la posicion de la meta
    plt.plot([0,0,10, 10,0], [0,10,10,0,0]) # dibujamos un cuadro delimitando el espacio de trabajo

class Obstaculo():
    def __init__(self, v1, v2):
        self.v1 = v1 # esquina superior
        self.v2 = v2 # esquina inferior

    def en_colision(self, punto):
        if self.v1[0] <= punto[0] <= self.v2[0] and self.v2[1] <= punto[1] <= self.v1[1]:
            return True
        return False
    
    def dibuja(self):
        x = [self.v1[0], self.v2[0], self.v2[0], self.v1[0], self.v1[0]]
        y = [self.v1[1], self.v1[1], self.v2[1], self.v2[1], self.v1[1]]
        plt.plot(x,y)

def es_punto_valido(punto, obstaculos, limites):
    # esta en el limite permitido?
    if limites[0] <= punto[0] <= limites[2] and limites[1] <= punto[1] <= limites[3] :
        # Hay colision
        for o in obstaculos:
            if o.en_colision(punto):
                return False
        return True
    return False

class Nodo():
    def __init__(self, pos, papa = None):
        self.pos = pos
        self.hijos = []
        self.papa = papa
        self.expandidos = []

    def genera_hijos(self, obstaculos, limites):
        global expandidos
        
        # uno arriba
        pos_arriba = self.pos[:]
        pos_arriba[1] += mov

        # uno abajo
        pos_abajo = self.pos[:]
        pos_abajo[1] -= mov
        
        # uno izq
        pos_izq = self.pos[:]
        pos_izq [0] -= mov
        
        # uno der
        pos_der = self.pos[:]
        pos_der[0] += mov
        
        # diagonales

        if es_punto_valido(pos_arriba, obstaculos, limites):
            # self.hijos.append(Nodo(pos_arriba, self))
            self.hijos.append(self.__class__(pos_arriba, self))

        if es_punto_valido(pos_abajo, obstaculos, limites):
            self.hijos.append(self.__class__(pos_abajo, self))
        
        if es_punto_valido(pos_izq, obstaculos, limites):
            self.hijos.append(self.__class__(pos_izq, self))
        
        if es_punto_valido(pos_der, obstaculos, limites):
            self.hijos.append(self.__class__(pos_der, self))

        #expandidos += self.hijos[:]


    def __eq__(self, n2, father = False):
        if father:
            return self.pos == n2.pos and self.papa.pos == n2.papa.pos
        return self.pos == n2.pos

    def __str__(self):
        s = f"{self.pos[0]}, {self.pos[1]}"
        return s

    def bpp(self, meta, robot, visitados = []):
        
        if self in visitados:
            return None
        
        expandidos.append(self)

        if self.pos == meta:
            return [self]

        self.genera_hijos(robot.obstaculos, robot.limites)
        visitados.append(self)

        for h in self.hijos:
            resp = h.bpp(meta, robot, visitados)
            if resp:
                resp.append(self)
                return resp
        
        return None

    def bpa(self, meta, robot, visitados = []):
        
        if self.pos == meta:
            return [self]
        
        if self in visitados:
            return None
        
        self.genera_hijos(robot.obstaculos, robot.limites)
        visitados.append(self)

        expandidos.append(self)

        por_visitar = self.hijos[:]

        while por_visitar!= []:
            h = por_visitar.pop(0)

            if h in visitados:
                continue

            expandidos.append(h)
            
            if h.pos == meta:
                camino = [h]
                papa = h.papa
                while papa:
                    camino.append(papa)
                    papa = papa.papa
                print("camino guardado...")
                print
                camino.reverse()
                return camino
            
            h.genera_hijos(robot.obstaculos, robot.limites)
            visitados.append(h)
            por_visitar += h.hijos
        
        return None

class Robot():
    def __init__(self, pos = [5,5], limites = [0,0,10,10], obstaculos = []):
        self.pos = pos
        self.limites = limites
        self.obstaculos = obstaculos
        self.trajectory = []
        self.raiz = None
    
    def agrega_obstaculo(self, obs):
        self.obstaculos.append(obs)

    def plot_robot(self):
        plt.scatter(self.pos[0], self.pos[1])

    def BPP(self, meta, visitados = []):
        self.raiz = Nodo(self.pos)
        camino = self.raiz.bpp(meta, self)
        self.trajectory = []
        for paso in camino:
            self.trajectory += paso.pos
        return camino

    def BPA(self, meta, visitados = []):
        self.raiz = Nodo(self.pos)
        camino = self.raiz.bpa(meta, self)
        self.trajectory = []

        for paso in camino:
            self.trajectory += paso.pos
        return camino

class NodoHeuristica(Nodo):
    def __init__(self, pos, papa = None):
        super(NodoHeuristica, self).__init__(pos, papa)
        if papa:
            self.costo = papa.costo + 1 # del nodo padre a este nodo
        else:
            self.costo = 0
        self.h = float("inf")

    
    def heuristica(self, meta):
        self.h = abs(self.pos[0] - meta[0]) + abs(self.pos[1] - meta[1])
        return self.h
    
    def f_n(self, meta):
        self.h = abs(self.pos[0] - meta[0]) + abs(self.pos[1] - meta[1]) + self.costo
        return self.h

    def bgreedy(self, meta, robot):
        print(f"tipo greedy: {type(self)}")
        visitados = []
        franja = [self] # por visitar
        while franja != []:
            h = franja.pop(0)
            if h in visitados:
                continue

            expandidos.append(h)

            if h.pos == meta:
                print("metaaaaaaa")
                camino = [h]
                papa = h.papa
                while papa:
                    camino.append(papa)
                    papa = papa.papa
                camino.reverse()
                return camino
            
            h.genera_hijos(robot.obstaculos, robot.limites)
            
            for i in h.hijos:
                i.heuristica(meta)
            
            franja += h.hijos
            franja.sort()
            visitados.append(h)


    def astar(self, meta, robot):
              
        visitados = []
        franja = [self] # por visitar
        while franja != []:
            h = franja.pop(0)

            if h in visitados:
                continue
            
            expandidos.append(h)

            if h.pos == meta:
                print("metaaaaaaa")
                camino = [h]
                papa = h.papa
                while papa:
                    camino.append(papa)
                    papa = papa.papa
                camino.reverse()
                return camino
            
            h.genera_hijos(robot.obstaculos, robot.limites)
            
            for i in h.hijos:
                i.f_n(meta)
            
            franja += h.hijos
            franja.sort()
            visitados.append(h)


    def __lt__(self, n2):
        return self.h < n2.h

class RobotHeur(Robot, Nodo):
    
    def __init__(self, pos=[5, 5], limites=[0, 0, 10, 10], obstaculos=[]):
        super(RobotHeur, self).__init__(pos, limites, obstaculos)
        self.raiz = NodoHeuristica(self.pos)

    def BGREEDY(self, meta):
        #raiz = NodoHeuristica(self.pos)

        camino = self.raiz.bgreedy(meta, self)
        if camino:
            self.trajectory = []
            for paso in camino:
                self.trajectory += paso.pos
        else:
            print("Camino no encontrado")
        return camino

    def ASTAR(self, meta):
        raiz = NodoHeuristica(self.pos)
        camino = raiz.astar(meta, self)
        if camino:
            self.trajectory = []
            for paso in camino:
                self.trajectory += paso.pos
        else:
            print("Camino no encontrado")
        return camino

expandidos = []
wall_E_BPP = Robot([5,0])
wall_E_BPP.agrega_obstaculo(Obstaculo([6,6],[10,2]))
wall_E_BPP.agrega_obstaculo(Obstaculo([5,9],[7,7]))
wall_E_BPP.agrega_obstaculo(Obstaculo([4,6],[5,4]))





camino = wall_E_BPP.BPP(meta=[8,8])
#plt.plot(wall_E_BPP.trajectory[0::2], wall_E_BPP.trajectory[1::2])
""" for p in expandidos:
    plt.scatter(p.pos[0], p.pos[1], c="k") """
x_points = wall_E_BPP.trajectory[0::2]
y_points = wall_E_BPP.trajectory[1::2]

x_points.reverse()
y_points.reverse()

print(f" expandidos {len(expandidos)}")
print(f"x: {x_points}")
print(f"y: {y_points}")




""" # Creamos la figura y los ejes
fig, ax = plt.subplots()

# Definimos el rango para la variable independiente x
x = np.linspace(0, 100, 100)


# Creamos la línea inicial con una onda sinusoidal
line, = ax.plot(x_points, y_points)

# Función de actualización para cada frame de la animación
def update(frame):
    global x
    # Creamos una nueva posición para la onda a medida que avanza el tiempo
    newx = [x_points[x], y_points[x]]
    x+=1
    # Actualizamos los datos de la línea con la nueva posición
    line.set_data(newx[0:], newx[1:])
    return line,

# Creamos la animación
ani = FuncAnimation(fig, update, frames=100, blit=True)

# Mostramos la animación
plt.show() """

# Asume que ya tienes x_points, y_points definidos y son del mismo tamaño
fig, ax = plt.subplots()
ax.set_xlim(min(x_points) - 1, max(x_points) + 1)
ax.set_ylim(min(y_points) - 1, max(y_points) + 1)

# Línea inicial vacía
line, = ax.plot([], [], 'b-', lw=2)

for obstaculo in wall_E_BPP.obstaculos:
    obstaculo.dibuja()
wall_E_BPP.plot_robot()
dibujar([8,8])

# Función de inicialización
def init():
    line.set_data([], [])
    return line,

# Función de actualización para la animación
def update(frame):
    line.set_data(x_points[:frame], y_points[:frame])
    return line,

# Creamos la animación
ani = FuncAnimation(
    fig, update, frames=len(x_points),
    init_func=init, blit=True, interval=100
)

plt.title("Camino del robot con BPP")
plt.grid()
plt.show()